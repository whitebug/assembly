     1                                  match:				; Начало подпрограммы
     2 00000000 55                      	push ebp		; Записываем значение ebp в стек чтоб сохранить
     3 00000001 89E5                    	mov ebp, esp		; Копируем в ebp значение esp, чтоб можно
     4                                  				; было продолжать пользоваться стеком
     5 00000003 83EC04                  	sub esp, 4		; Выделяем память (стека) под локальную 
     6                                  				; переменную I [ebp-4], т.е. тупо вычли 4
     7 00000006 56                      	push esi		; Сохраняем в стеке esi
     8 00000007 57                      	push edi		; Сохраняем в стеке edi
     9 00000008 8B7508                  	mov esi, [ebp+8]	; Записываем в ESI значение строки
    10                                  				; из параметра подпрограммы
    11 0000000B 8B7D0C                  	mov edi, [ebp+12]	; Записываем в EDI значение образца
    12                                  .again:				; Сюда мы вернемся, когда сопоставим
    13                                  				; очередной символ и сдвинемся
    14 0000000E 803F00                  	cmp byte [edi], 0	; Проверяем равно ли значение по [edi] нулю
    15 00000011 750B                    	jne .not_end		; Если не равно, переходим на метку
    16 00000013 803E00                  	cmp byte [esi], 0	; Образец кончился, кончилась ли строка?
    17 00000016 0F854E000000            	jne near .false		; Если строка не кончилась, вернуть ЛОЖЬ
    18 0000001C EB45                    	jmp .true		; Если строка и образец кончились одновременно
    19                                  				; Вернуть ИСТИНА
    20                                  .not_end:			; Если образец не кончился
    21 0000001E 803F2A                  	cmp byte [edi], '*'	; Проверим есть ли в начале звездочка
    22 00000021 752B                    	jne .not_star		; Если не звездочка - уходим из секции
    23                                  				; Если звездочка, организуем цикл
    24 00000023 C745FC00000000          	mov dword [ebp-4], 0	; I := 0
    25                                  .star_loop:
    26                                  				; Готовимся к рекурсивному вызову
    27 0000002A 89F8                    	mov eax, edi		; Сначала обрабатываем образец
    28 0000002C 40                      	inc eax			; Рассматриваем образец со следующего символа
    29 0000002D 50                      	push eax		; Записываем eax в стек
    30 0000002E 89F0                    	mov eax, esi		; Теперь обрабатываем строку
    31 00000030 0345FC                  	add eax, [ebp-4]	; Начинаем строку с I-ого символа 
    32                                  				; напомним, что [ebp-4] - это I
    33 00000033 50                      	push eax		; Записываем eax в стек
    34 00000034 E8C7FFFFFF              	call match		; Вызываем сами себя с новыми параметрами
    35 00000039 83C408                  	add esp, 8		; После вызова очищаем стек
    36 0000003C 85C0                    	test eax, eax		; Проверяем, вернули ли нам ноль на выходе
    37                                  				; из нашей же подпрограммы
    38 0000003E 7523                    	jnz .true		; Вернули ИСТИНУ. Т.е. остаток строки
    39                                  				; сопоставился с остатоком образца
    40 00000040 0345FC                  	add eax, [ebp-4]	; Вернули 0 (ЛОЖЬ). Продвинемся дальше по
    41                                  				; слову, вдруг дальше будут совпадения
    42                                  				; поэтому увеличим адрес
    43 00000043 803C0600                	cmp byte [esi+eax], 0	; Не кончилась ли строка?
    44 00000047 7421                    	je .false		; Если строка кончилась, вернем ЛОЖЬ
    45 00000049 FF45FC                  	inc dword [ebp-4]	; Если строка не кончилась, увеличим I
    46 0000004C EBDC                    	jmp .star_loop		; И вернемся в начало цикла
    47                                  .not_star:			; Образец не пуст и не начинается с *
    48 0000004E 8A07                    	mov al, [edi]		; Копируем образец в регистр
    49 00000050 3C3F                    	cmp al, '?'		; Может в образце знак ?
    50 00000052 7406                    	je .quest		; Если да, то идем в .quest
    51 00000054 3A06                    	cmp al, [esi]		; Если знака вопроса нет, надо сравнить
    52                                  				; образец и строку. Если что-то общее в них
    53                                  				; есть, то символы должны совпасть.
    54 00000056 7512                    	jne .false		; Если не совпало, то вернем ЛОЖЬ
    55 00000058 EB05                    	jmp .goon		; Если совпадение - продолжаем просмотр
    56                                  .quest:				; Образец начинается с ?
    57 0000005A 803E00                  	cmp byte [esi], 0	; Не кончилась ли строка?
    58 0000005D 740B                    	jz .false		; Если кончилась, то ЛОЖЬ
    59 0000005F 46                      .goon: 	inc esi			; Символы совпали, сдвигаемся по строке
    60 00000060 47                      	inc edi			; И по образцу тоже сдвигаемся
    61 00000061 EBAB                    	jmp .again		; Повторяем цикл
    62                                  .true:				; Переходим сюда чтоб вернуть ИСТИНУ
    63 00000063 B801000000              	mov eax, 1		; Вписываем ИСТИНУ в регистр
    64 00000068 EB02                    	jmp .quit		; Переходим к выходу
    65                                  .false:				; Переходим сюда чтоб вернуть ЛОЖЬ
    66 0000006A 31C0                    	xor eax, eax		; Обнуляем eax (т.е. возвращем ЛОЖЬ)
    67                                  .quit:				; Конец работы
    68 0000006C 5F                      	pop edi			; Вернем из стека edi
    69 0000006D 5E                      	pop esi			; Вернем из стека esi
    70 0000006E 89EC                    	mov esp, ebp		; Вернем указатель стека на прежнее место
    71 00000070 5D                      	pop ebp			; Вернем из стека ebp
    72 00000071 C3                      	ret			; Вернем управление в основной код
