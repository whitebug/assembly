match:				; Начало подпрограммы
	push ebp		; Записываем значение ebp в стек чтоб сохранить
	mov ebp, esp		; Копируем в ebp значение esp, чтоб можно
				; было продолжать пользоваться стеком
	sub esp, 4		; Выделяем память (стека) под локальную 
				; переменную I [ebp-4], т.е. тупо вычли 4
	push esi		; Сохраняем в стеке esi
	push edi		; Сохраняем в стеке edi
	mov esi, [ebp+8]	; Записываем в ESI значение строки
				; из параметра подпрограммы
	mov edi, [ebp+12]	; Записываем в EDI значение образца
.again:				; Сюда мы вернемся, когда сопоставим
				; очередной символ и сдвинемся
	cmp byte [edi], 0	; Проверяем равно ли значение по [edi] нулю
	jne .not_end		; Если не равно, переходим на метку
	cmp byte [esi], 0	; Образец кончился, кончилась ли строка?
	jne near .false		; Если строка не кончилась, вернуть ЛОЖЬ
	jmp .true		; Если строка и образец кончились одновременно
				; Вернуть ИСТИНА
.not_end:			; Если образец не кончился
	cmp byte [edi], '*'	; Проверим есть ли в начале звездочка
	jne .not_star		; Если не звездочка - уходим из секции
				; Если звездочка, организуем цикл
	mov dword [ebp-4], 0	; I := 0
.star_loop:
				; Готовимся к рекурсивному вызову
	mov eax, edi		; Сначала обрабатываем образец
	inc eax			; Рассматриваем образец со следующего символа
	push eax		; Записываем eax в стек
	mov eax, esi		; Теперь обрабатываем строку
	add eax, [ebp-4]	; Начинаем строку с I-ого символа 
				; напомним, что [ebp-4] - это I
	push eax		; Записываем eax в стек
	call match		; Вызываем сами себя с новыми параметрами
	add esp, 8		; После вызова очищаем стек
	test eax, eax		; Проверяем, вернули ли нам ноль на выходе
				; из нашей же подпрограммы
	jnz .true		; Вернули ИСТИНУ. Т.е. остаток строки
				; сопоставился с остатоком образца
	add eax, [ebp-4]	; Вернули 0 (ЛОЖЬ). Продвинемся дальше по
				; слову, вдруг дальше будут совпадения
				; поэтому увеличим адрес
	cmp byte [esi+eax], 0	; Не кончилась ли строка?
	je .false		; Если строка кончилась, вернем ЛОЖЬ
	inc dword [ebp-4]	; Если строка не кончилась, увеличим I
	jmp .star_loop		; И вернемся в начало цикла
.not_star:			; Образец не пуст и не начинается с *
	mov al, [edi]		; Копируем образец в регистр
	cmp al, '?'		; Может в образце знак ?
	je .quest		; Если да, то идем в .quest
	cmp al, [esi]		; Если знака вопроса нет, надо сравнить
				; образец и строку. Если что-то общее в них
				; есть, то символы должны совпасть.
	jne .false		; Если не совпало, то вернем ЛОЖЬ
	jmp .goon		; Если совпадение - продолжаем просмотр
.quest:				; Образец начинается с ?
	cmp byte [esi], 0	; Не кончилась ли строка?
	jz .false		; Если кончилась, то ЛОЖЬ
.goon: 	inc esi			; Символы совпали, сдвигаемся по строке
	inc edi			; И по образцу тоже сдвигаемся
	jmp .again		; Повторяем цикл
.true:				; Переходим сюда чтоб вернуть ИСТИНУ
	mov eax, 1		; Вписываем ИСТИНУ в регистр
	jmp .quit		; Переходим к выходу
.false:				; Переходим сюда чтоб вернуть ЛОЖЬ
	xor eax, eax		; Обнуляем eax (т.е. возвращем ЛОЖЬ)
.quit:				; Конец работы
	pop edi			; Вернем из стека edi
	pop esi			; Вернем из стека esi
	mov esp, ebp		; Вернем указатель стека на прежнее место
	pop ebp			; Вернем из стека ebp
	ret			; Вернем управление в основной код
